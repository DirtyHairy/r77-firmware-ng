/*
 * (C) Copyright 2012
 *     wangflord@allwinnertech.com
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program;
 *
 */
#ifndef  __boot0_v2_h
#define  __boot0_v2_h

#define STAMP_VALUE                     0x5F0A6C39


typedef struct
{
	unsigned int		ChannelCnt;
	unsigned int        ChipCnt;                            //the count of the total nand flash chips are currently connecting on the CE pin
    unsigned int       ChipConnectInfo;                    //chip connect information, bit == 1 means there is a chip connecting on the CE pin
	unsigned int		RbCnt;
	unsigned int		RbConnectInfo;						//the connect  information of the all rb  chips are connected
    unsigned int        RbConnectMode;						//the rb connect  mode
	unsigned int        BankCntPerChip;                     //the count of the banks in one nand chip, multiple banks can support Inter-Leave
    unsigned int        DieCntPerChip;                      //the count of the dies in one nand chip, block management is based on Die
    unsigned int        PlaneCntPerDie;                     //the count of planes in one die, multiple planes can support multi-plane operation
    unsigned int        SectorCntPerPage;                   //the count of sectors in one single physic page, one sector is 0.5k
    unsigned int       PageCntPerPhyBlk;                   //the count of physic pages in one physic block
    unsigned int       BlkCntPerDie;                       //the count of the physic blocks in one die, include valid block and invalid block
    unsigned int       OperationOpt;                       //the mask of the operation types which current nand flash can support support
    unsigned int        FrequencePar;                       //the parameter of the hardware access clock, based on 'MHz'
    unsigned int        EccMode;                            //the Ecc Mode for the nand flash chip, 0: bch-16, 1:bch-28, 2:bch_32
    unsigned char       NandChipId[8];                      //the nand chip id of current connecting nand chip
    unsigned int       ValidBlkRatio;                      //the ratio of the valid physical blocks, based on 1024
	unsigned int 		good_block_ratio;					//good block ratio get from hwscan
	unsigned int		ReadRetryType;						//the read retry type
	unsigned int       DDRType;
	unsigned int		Reserved[32];
}boot_nand_para_t0;


//ͨ�õģ���GPIO��ص����ݽṹ
typedef struct _normal_gpio_cfg
{
    unsigned char      port;                       //�˿ں�
    unsigned char      port_num;                   //�˿��ڱ��
    char      mul_sel;                    //���ܱ��
    char      pull;                       //����״̬
    char      drv_level;                  //������������
    char      data;                       //�����ƽ
    unsigned char      reserved[2];                //����λ����֤����
}
normal_gpio_cfg;

/******************************************************************************/
/*                              file head of Boot0                            */
/******************************************************************************/
typedef struct _boot0_private_head_t
{
	unsigned int            prvt_head_size;
	char                    prvt_head_vsn[4];       // the version of boot0_private_head_t
	unsigned int            dram_para[32];          // DRAM patameters for initialising dram. Original values is arbitrary,
	int						uart_port;              // UART���������
	normal_gpio_cfg         uart_ctrl[2];           // UART������(���Դ�ӡ��)������Ϣ
	int                     enable_jtag;            // 1 : enable,  0 : disable
    normal_gpio_cfg	        jtag_gpio[5];           // ����JTAG��ȫ��GPIO��Ϣ
    normal_gpio_cfg         storage_gpio[32];       // �洢�豸 GPIO��Ϣ
    char                    storage_data[512 - sizeof(normal_gpio_cfg) * 32];      // �û�����������Ϣ
    //boot_nand_connect_info_t    nand_connect_info;
}boot0_private_head_t;


typedef struct standard_Boot_file_head
{
	unsigned int  jump_instruction;   // one intruction jumping to real code
	unsigned char   magic[8];           // ="eGON.BT0" or "eGON.BT1",  not C-style string.
	unsigned int  check_sum;          // generated by PC
	unsigned int  length;             // generated by PC
	unsigned int  pub_head_size;      // the size of boot_file_head_t
	unsigned char   pub_head_vsn[4];    // the version of boot_file_head_t
	unsigned char   file_head_vsn[4];   // the version of boot0_file_head_t or boot1_file_head_t
	unsigned char   Boot_vsn[4];        // Boot version
	unsigned char   eGON_vsn[4];        // eGON version
	unsigned char   platform[8];        // platform information
}standard_boot_file_head_t;


typedef struct _boot0_file_head_t
{
	standard_boot_file_head_t   boot_head;
	boot0_private_head_t  		prvt_head;
}boot0_file_head_t;

typedef struct sbrom_toc0_config
{
	unsigned char    	config_vsn[4];
	unsigned int      	dram_para[32];  	// dram²ÎÊý
	int				  	uart_port;      	// UART¿ØÖÆÆ÷±àºÅ
	normal_gpio_cfg   	uart_ctrl[2];    	// UART¿ØÖÆÆ÷GPIO
	int              	enable_jtag;    	// JTAGÊ¹ÄÜ
	normal_gpio_cfg   	jtag_gpio[5];    	// JTAG¿ØÖÆÆ÷GPIO
	normal_gpio_cfg  	storage_gpio[50]; 	// ´æ´¢Éè±¸ GPIOÐÅÏ¢
                							// 0-23·Ånand£¬24-31´æ·Å¿¨0£¬32-39·Å¿¨2
                							// 40-49´æ·Åspi
	char   				storage_data[384];  // 0-159,´æ´¢nandÐÅÏ¢£»160-255,´æ·Å¿¨ÐÅÏ¢
	unsigned int        secure_dram_mbytes; //
	unsigned int        drm_start_mbytes;   //
	unsigned int        drm_size_mbytes;    //
	unsigned int      	res[8];   			// ×Ü¹²1024×Ö½Ú
}sbrom_toc0_config_t;

typedef struct
{
	u8  name[8];	  //×Ö·û´®£¬¿ÉÒÔ¸ü¸Ä£¬Ã»ÓÐ×÷ÏÞÖÆ
	u32 magic;	      //±ØÐëÊÇ0x89119800
	u32 check_sum;    //Õû¸öÊý¾ÝµÄÐ£ÑéºÍ£¬²Î¿¼ÏÖÔÚboot0×ö·¨

	u32 serial_num;   //ÐòÁÐºÅ£¬¿ÉÒÔ¸ü¸Ä£¬Ã»ÓÐÏÞÖÆ
	u32 status;       //¿ÉÒÔ¸ü¸Ä£¬Ã»ÓÐÏÞÖÆ

	u32 items_nr;	  //×ÜµÄÏîÄ¿¸öÊý£¬¶ÔTOC0À´Ëµ£¬±ØÐëÊÇ2
	u32 length;	      //TOC0µÄ³¤¶È
	u8  platform[4];  //toc_platform[0]±êÊ¾Æô¶¯½éÖÊ
                      //0£ºnand£»1£º¿¨0£»2£º¿¨2£»3£ºspinor
	u32 reserved[2];  //±£ÁôÎ»
	u32 end;          //±íÊ¾Í·²¿½á¹¹Ìå½áÊø£¬±ØÐëÊÇ0x3b45494d

}toc0_private_head_t;
#define SBROM_TOC0_HEAD_SPACE 0x80







#endif     //  ifndef __boot0_h

/* end of boot0.h */
